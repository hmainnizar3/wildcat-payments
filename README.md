# Wildcat Payments

- [Scoping](#scoping)
  - [1. Display a list of all payments made through the system](#1-display-a-list-of-all-payments-made-through-the-system)
  - [2. Failure tolerance](#2-failure-tolerance)
  - [3. "100 payments getting into the system"](#3-100-payments-getting-into-the-system)
  - [4. Allow filtering payments per customer ü•Ö](#4-allow-filtering-payments-per-customer-)
  - [5. Authentication / Authorization](#5-authentication--authorization)
- [First sketch of the architecture üè∞](#first-sketch-of-the-architecture-)
  - [Steps](#steps)
- [Backend üíæ](#backend-)
  - [Building blocks üèóÔ∏è](#building-blocks-)
  - [Testing üß™](#testing-)
  - [Performance üîã](#performance-)
    - [Backend](#backend)
    - [Frontend](#frontend)
- [Frontend](#frontend)
  - [Demo video üé•](#demo-video-)
- [Improvements](#improvements)
  - [Failure tolerance](#failure-tolerance)
  - [Deployment](#deployment)
  - [Scalability](#scalability)

<div style="display: flex; justify-content: center;">
	<img src="./wild-cat.png" alt="Wildcat Systems Logo" style="width: 20%; height: auto;">
</div>

_(Generic logo generated by DALL-E 2)_

#### Scoping

#### 1. Display a list of all payments made through the system

- CRUD interface for payments with auth, payments need to somehow be written to a database.
- I have made the assumption that payments resolve instantaneously. In the real world, that's most likely not the case. I will address this point in the scalability point a bit more below on how we could architecture a system that would be able to handle that.

#### 2. Failure tolerance

- I have also made the assumption that payments do not fail, and there is no recovery strategy or fault failure tolerance. I talk about this a bit more here [Failure tolerance](#failure-tolerance)

#### 3. "100 payments getting into the system"

**Heavy on writes**

Any framework/language should be able to do this without any significant problem (as long as the function creating the payment isn't doing too many checks). If this was number

If this number was much higher, I would also consider writing this API in rust or [something at least much faster node](https://tokio.rs/) (not to say that node is technically slow, it's actually pretty good for IO intensive operations).

If we had a larger scale system, we would have to think about how to structure the writes. We would have one write database, and multiple read databases probably.

If the requests per minute are absolutely through the roof, we could also consider a NoSQL alternative instead of Postgres in this case. Apache cassandra, MongoDB or Elasticsearch would all work.

**Not too heavy on the reads**

I anticipate some read operations, but it would nothing be too crazy. I would add a Redis instance for example to cache the user information.

#### 4. Allow filtering payments per customer ü•Ö

We need to run a couple of filters, in this case, the system can be able to take the following parameters as input:

```
dateRange: from and to date
customerFilter
userFilter
paymentRefID
```

Again, in a real world scenario, we would optimize things differently depending on what is most often run. You can read more [Payment data model](./backend/src/entity/Payment.ts).

The most interesting part in there is that I'm using 2 IDs. One is the primary `id` key (`UUID v4`) that is generated by the db when it's created.
The second id is the `paymentRefId`, which is also a `UUID v4` but is completely independent from the primary `id`. You might ask why? The reason is because if we ever were to move the data from Postgres to another database, we would maintain the `paymentRefId` and not carry over the Postgres generated indexes. The `paymentRefId` is tech-agnostic, it's a business-domain piece of information, so it helps keeping things separate and more clear.

#### 5. Authentication / Authorization

We have essentially two types of _users_ in this system:

- One is a `user`, which represents the physical person logging in our system and executing operations.
- The other one is a `customer` which represents a virtual person executing payment operations (or other things as well).

One `user` can have multiple `customers` essentially.
There is a joint table that connects both of them. If i had two shops, I would login as one `user` and execute `payments` for each of my `shops`.

This way we would also get the very granular permissions that comes from this decoupling.

There is no notion of an `ADMIN` role or a `USER` role. Any user has visibility to a `set` of specific `users`. This is due to **prevent** any user from potentially having `full-access` to. It also makes it easier to temporary grant certain users permissions for certain `customers` and then retract them without granting them full-system access.

A `user` can execute a payment **on behalf of his own customer**.

Users get a `jwt_access_token` signed by the server that lasts for a given amount of time. With this access, they'll be able to do any sort of operations they want.
I'm no expert in authentication strategies, but I would do my research before hand on what the trendy way of auth strategies are out there and is definitely not my field of expertise.

#### First sketch of the architecture üè∞

<div style="display: flex; justify-content: center;">
	<img src="./Wild payments.drawio.png" alt="Wildcat Systems Logo" >
</div>

### Steps

In order to spend the least amount of possible time I've broken down the problems into this minimal set of acceptance criteria:

- ‚úÖ I need an create `users`
- ‚úÖ I need a way to create `customers`
- ‚úÖ I need an endpoint to authenticate users
- ‚úÖ I need a way to create `payments`
- ‚úÖ I need a way to `link` and `unlink` specific `customers` to specific `users`
- ‚ö†Ô∏è update the `customers` information is missing too
- ‚úÖ I need some tests are I'm writing the code, to prevent any refactoring from silently break the essential apis.

Frontend

- ‚úÖ I need to show a table of the payments with a couple of filters
- ‚ö†Ô∏è internalization and localization was not really thought off
- ‚ö†Ô∏è Mobile-support not tested.
- ‚ö†Ô∏è The authorization login/logout step will be omitted for the sake of time
- ‚ö†Ô∏è e2e missing completely, although I would use `cypress` if I could

## Backend üíæ

I decided to write a node rest api, because I felt like it would just be simpler to keep everything in a TS context in my head.

I did not want to do it in .NET core or Scala (Akka) because of all the plumbing that is needed to get started.

Django and Ruby on Rails are also renowned to be fast at bootstrapping, but I've never touched (haven't in a very long time done that).

I also thought about writing the payment api in rust entirely, but I eventually convinced myself that it would take a bit more than 4 hours to do the whole thing.

### Building blocks üèóÔ∏è

- TypeORM
- Express
- Postgres

Steps to run this project:

```
docker-compose up
yarn install
yarn start
(or yarn dev, if you want hot-reloading)
```

The database should be maintained in sync automatically. Not a great thing to do in PROD but it's fine for this demo

The proper way to do that would be to actually run generate migrations and run them.

I used sequelize initially but then realized that their Typing system was more of an afterthought, and generating migrations and so on was really a headache. (If you use sequelize/typescript, you can't generate them.)

https://github.com/sequelize/sequelize-typescript

I then pivoted to use https://typeorm.io/, which turned out to do everything I needed.

It's the first time I either, but I basically needed a many-to-many between customers and users.

## Testing üß™

There are basic smoke tests.
I also didn't bother making them **deterministic**, because of all the plumbing that might be needed because of time constraints.

<div style="display: flex">
	<img src="./test.png" alt="test" style="width: 70%; height: auto;">
</div>

## Performance üîã

#### Backend

It was stable with even 1000 payments. I did not try to go to 10000

I also added a simple bash script that does exactly 100 payments/second.
[send_100_requests.sh](./send_100_requests.sh)

_The test on Mac 14-inch M1 Pro, 2021 (32Gb RAM), which is a fairly strong machine, not sure how it would perform in real life conditions._

#### Frontend

The performance is really good in the frontend, I however did not run any benchmarks to prove that like Google lighthouse or so.

## Frontend

I've used React, in conjunction with Antd (component library) that allows to create things quite quickly.

For the networking part, I'm using `axios` and `swr`.

Nothing really special on this side to be honest, I'm using normal standard pagination, so there was no need for virtual tables (for performance reasons) and it was just simpler to implement.

In order to run the thing you can run the following

```
yarn start
```

### Demo video üé•

I made a short video that is accessible here

https://www.youtube.com/watch?v=94I7R2Fvre8

![Demo screenshot](screen.png)

## Improvements

### Failure tolerance

As mentioned in the beginning, with the assumption of payments never failing, I did not implement any failure tolerance.

- Retry queues
- Dead letter queue

Let's assume database or table to keep track of which payments would fail.

- Retryable failures are routed to a retry queue.
- For non-retryable failures such as invalid input, errors would be store in that database.

If the payment fails again for one reason or another, the event would be routed to the dead letter queue. We can then use the dead letter queue to investigate payments that failed.

The worst thing that could happen is double-charing a customer for example.

When we make this retries, we have to make sure that only one of those retry operation goes through.

When doing these retries, there are also a couple of retry strategies that we could use, immediate retry, incremental and exponential (we would see which one is the best one in our case).

Another problem with this is that we have to make sure that we have **exactly-once delivery** system. **idempotency** is crucial here. If multiple concurrent requests are detected with the same idempotency key, only one request should be processed.

When receiving a payment, we would insert a row in the db.
A successful insertion means that the payment that we just received did not exist, so the second request will not be processed.

I did not write a test for it, but this is an interesting test case scenario.

### Scalability

- A queueing system would help a lot here, I'm not sure on how many payments this system can take before it goes down.
- I think using GraphQL here would be quite nice, as the payment object can eventually become a bit big and it would help the frontend only consume the data that it needs. This is not from a performance pov but more of a logical and semantic pov.
- Writing the high-intensity systems in a more performant language.

### Deployment

I didn't have time for this one.
