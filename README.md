# Wildcat Payments

<div style="display: flex; justify-content: center;">
	<img src="./wild-cat.png" alt="Wildcat Systems Logo" style="width: 20%; height: auto;">
</div>

_(Generic logo generated by DALL-E 2)_

#### Breaking down the main points

#### 1. Display a list of all payments made through the system

- CRUD interface for payments with auth, payments need to somehow be written to a database.
- I have made the assumption that payments resolve instantaneously. In the real world, that's most likely not the case. I will address this point in the scalability point a bit more below on how we could architecture a system that would be able to handle that.

#### Failure tolerance

- I have also made the assumption that payments do not fail, and there is no recovery strategy or fault failure tolerance. I will address this a bit more after the breakdown

#### 2. "100 payments getting into the system"

**Heavy on writes**

Any framework/language should be able to do this without any significant problem (as long as the function creating the payment isn't doing too many checks). If this was number

If this number was much higher, I would also consider writing this API in rust or [something at least much faster node](https://tokio.rs/) (not to say that node is technically slow, it's actually pretty good for IO intensive operations).

If we had a larger scale system, we would have to think about how to structure the writes. We would have one write database, and multiple read databases probably.

If the requests per minute are absolutely through the roof, we could also consider a NoSQL alternative instead of Postgres in this case. Apache cassandra, MongoDB or Elasticsearch would all work.

**Not too heavy on the reads**

I anticipate some read operations, but it would nothing be too crazy. I would add a Redis instance for example to cache the user information.

#### 2. Allow filtering payments per customer

We need to run a couple of filters, in this case, the system can be able to take the following parameters as input:

```
dateRange: from and to date
customerFilter
userFilter
paymentRefID
```

Again, in a real world scenario, we would optimize things differently depending on what is most often run. You can read more [Payment data model](./backend/src/entity/Payment.ts).

The most interesting part in there is that I'm using 2 IDs. One is the primary `id` key (`UUID v4`) that is generated by the db when it's created.
The second id is the `paymentRefId`, which is also a `UUID v4` but is completely independent from the primary `id`. You might ask why? The reason is because if we ever were to move the data from Postgres to another database, we would maintain the `paymentRefId` and not carry over the Postgres generated indexes. The `paymentRefId` is tech-agnostic, it's a business-domain piece of information, so it helps keeping things separate and more clear.

#### 3. Authentication / Authorization

We have essentially two types of _users_ in this system:

- One is a `user`, which represents the physical person logging in our system and executing operations.
- The other one is a `customer` which represents a virtual person executing payment operations (or other things as well).

One `user` can have multiple `customers` essentially.
There is a joint table that connects both of them. If i had two shops, I would login as one `user` and execute `payments` for each of my `shops`.

This way we would also get the very granular permissions that comes from this decoupling.

There is no notion of an `ADMIN` role or a `USER` role. Any user has visibility to a `set` of specific `users`. This is due to **prevent** any user from potentially having `full-access` to. It also makes it easier to temporary grant certain users permissions for certain `customers` and then retract them without granting them full-system access.

A `user` can execute a payment **on behalf of his own customer**.

Users get a `jwt_access_token` signed by the server that lasts for a given amount of time. With this access, they'll be able to do any sort of operations they want.
I'm no expert in authentication strategies, but I would do my research before hand on what the trendy way of auth strategies are out there and is definitely not my field of expertise.

#### First sketch of the architecture

<div style="display: flex; justify-content: center;">
	<img src="./Wild payments.drawio.png" alt="Wildcat Systems Logo" >
</div>

### Engineering steps

In order to spend the least amount of possible time I've broken down the problems into this minimal set of acceptance criterias:

- ✅ I need an create `users`
- ✅ I need a way to create `customers`
- ✅ I need an endpoint to authenticate users
- ✅ I need a way to create `payments`
- ✅ I need a way to `link` and `unlink` specific `customers` to specific `users`
- ⚠️ update the `customers` information is missing too
- ✅ I need some tests are I'm writing the code, to prevent any refactoring from silently break the essential apis.

Frontend

- ✅ I need to show a table of the payments with a couple of filters
- ⚠️ internalization and localization was not really thought off
- ⚠️ Mobile-support not tested.
- ⚠️ The authorization login/logout step will be omitted for the sake of time
- ⚠️ e2e missing completely, allthought I would use `cypress` if I could

## Backend

I decided to write a node rest api, because I felt like it would just be simpler to keep everything in a TS context in my head.

I did not want to do it in .NET core or Scala (Akka) because of all the plumbing that is needed to get started.

Django and Ruby on Rails have fast start up time, but I've never touched (haven't in a very long time done that).

I also thought about writing the payment api in rust entirely, but I eventually convinced myself that it would take a bit more than 4 hours to do the whole thing.

### Building blocks

- TypeORM
- Express
- Postgres

Steps to run this project:

```
docker-compose up
yarn install
yarn start
(or yarn dev, if you want hot-reloading)
```

The database should be maintained in sync automatically. Not a great thing to do in PROD but it's fine for this demo

The proper way to do that would be to actually run generate migrations and run them.

I used sequelize initially but then realized that their Typing system was more of an afterthought, and generating migrations and so on was really a headache. (If you use sequelize/typescript, you can't generate them.)

https://github.com/sequelize/sequelize-typescript

I then pivoted to use https://typeorm.io/, which turned out to do everything I needed.

It's the first time I either, but I basically needed a many-to-many between customers and users.

I don't usually spin up backends from scratch, as most of the time, the infrastructure and the plumbing is already there, so I had to hack it up in one way.

## Performance testing

I also added a simple bash script that does exactly 100 payments/second.
[send_100_requests.sh](./send_100_requests.sh)

## Frontend

I've used React, in conjuction with Antd (component library) that allows to create things quite quickly.

For the networking part, I'm using `axios` and `swr`.

Nothing really special on this side to be honest, I'm using normal standard pagination, so there was no need for virtual tables (for performance reasons) and it was just simpler to implement.

In order to run the thing you can run the following

```
yarn start
```

### Demo video

![video](https://streamable.com/e/b4o09l)

![Demo screenshot](screen.png)
